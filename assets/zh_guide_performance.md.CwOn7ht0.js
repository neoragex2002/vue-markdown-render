import{_ as s,c as a,o as e,ag as n}from"./chunks/framework.C0wiDQbp.js";const c=JSON.parse('{"title":"性能特性与建议","description":"","frontmatter":{},"headers":[],"relativePath":"zh/guide/performance.md","filePath":"zh/guide/performance.md"}'),t={name:"zh/guide/performance.md"};function l(h,i,k,d,p,r){return e(),a("div",null,[...i[0]||(i[0]=[n(`<h1 id="性能特性与建议" tabindex="-1">性能特性与建议 <a class="header-anchor" href="#性能特性与建议" aria-label="Permalink to &quot;性能特性与建议&quot;">​</a></h1><p>本渲染器针对流式与大型文档进行优化。</p><p>关键功能：</p><ul><li>针对代码块的增量解析</li><li>最小化的 DOM 更新与内存优化</li><li>Monaco 的流式更新</li><li>渐进式 Mermaid 渲染</li></ul><p>性能建议：</p><ul><li>将长文档分块流式传输，避免阻塞主线程</li><li>对只读代码块使用 <code>MarkdownCodeBlockNode</code> 或 <code>renderCodeBlocksAsPre</code></li><li>使用 <code>setDefaultMathOptions</code> 在应用启动时设置数学渲染默认项</li><li>对重型节点启用 <code>viewportPriority</code>（默认开启）以延迟离屏工作</li></ul><p>更多详细信息见 <code>/zh/guide/performance</code>。</p><h2 id="让渲染保持稳定的-逐字更新" tabindex="-1">让渲染保持稳定的“逐字更新” <a class="header-anchor" href="#让渲染保持稳定的-逐字更新" aria-label="Permalink to &quot;让渲染保持稳定的“逐字更新”&quot;">​</a></h2><p>有些 LLM 会一次推送大量文本，导致前端表现为“卡顿一会儿再一次性显示”。想让用户始终看到稳定的打字机效果，可以：</p><ul><li><strong>保持 <code>typewriter</code> 为默认开启</strong>，这样非代码节点都会通过进入动画逐字呈现。</li><li><strong>调整批次渲染参数</strong>：调低 <code>initialRenderBatchSize</code> / <code>renderBatchSize</code>（如 <code>12</code> / <code>24</code>），并设置一个 20–30 ms 的 <code>renderBatchDelay</code>，让每次渲染只插入很小的一段文本。</li><li><strong>在上游做节流或拆包</strong>：把后端一次性推送的大段文本按段落拆分，或用 50–100 ms 的防抖再更新 <code>content</code>，减少一次性 diff。</li><li><strong>保留延迟可见渲染</strong>：继续启用 <code>deferNodesUntilVisible</code> / <code>viewportPriority</code>，避免 Mermaid、Monaco 这类重型节点阻塞文字流。</li><li><strong>必要时降级代码块</strong>：在突发大块传输时暂时关闭 <code>codeBlockStream</code> 或启用 <code>renderCodeBlocksAsPre</code>，避免语法高亮抢占时间片。</li></ul><p>这些组合可以把 DOM 工作量稳定在可控范围，哪怕服务端一次发送很多文本，用户也会感知为持续、丝滑的逐字输出。</p><h2 id="虚拟化与-dom-窗口" tabindex="-1">虚拟化与 DOM 窗口 <a class="header-anchor" href="#虚拟化与-dom-窗口" aria-label="Permalink to &quot;虚拟化与 DOM 窗口&quot;">​</a></h2><p><code>NodeRenderer</code> 会维护一个滑动窗口，只让一部分节点常驻 DOM，从而在极长的对话或文档中保持流畅：</p><ul><li><code>maxLiveNodes</code>（默认 <code>320</code>）定义了 DOM 中最多保留多少个已完全渲染的节点。减小可以省内存、增大可以保留更多回溯内容。</li><li><code>liveNodeBuffer</code> 控制窗口前后的超前/超后范围（默认 <code>60</code>）。如果节点高度差异巨大，可增大该值以避免快速滚动时闪烁。</li><li><code>deferNodesUntilVisible</code> 搭配 <code>viewportPriority</code> 使用，可以让 Mermaid、Monaco、KaTeX 等重型节点在进入视口之前保持占位骨架。</li><li><code>batchRendering</code> 以及 <code>initialRenderBatchSize</code>、<code>renderBatchSize</code>、<code>renderBatchDelay</code>、<code>renderBatchBudgetMs</code> 控制每一帧有多少节点从占位态切换为真实组件。该增量模式仅在关闭虚拟化（<code>:max-live-nodes=&quot;0&quot;</code>）时生效；默认开启虚拟化时，所有节点会立即渲染，依靠窗口裁剪来限制 DOM 工作量。</li></ul><p>示例：在保持可滚动回溯的同时降低 DOM 开销。</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">MarkdownRender</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">md</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">max-live-nodes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">220</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">live-node-buffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">40</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">batch-rendering</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">initial-render-batch-size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render-batch-size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">48</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render-batch-delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render-batch-budget-ms</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defer-nodes-until-visible</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">viewport-priority</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/&gt;</span></span></code></pre></div><p>利用这些旋钮，可以把超长 AI 对话或技术文档维持在一个稳定的 CPU / 内存预算中，同时保持滚动与输入的流畅体验。</p>`,17)])])}const E=s(t,[["render",l]]);export{c as __pageData,E as default};
